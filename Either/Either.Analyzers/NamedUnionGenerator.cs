using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RhymesOfUncertainty;

[Generator]
public class NamedUnionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: "RhymesOfUncertainty.NamedUnionTypeAttribute",
            predicate: static (node, cancellationToken) => node.IsKind(SyntaxKind.StructDeclaration),
            transform: static (ctx, cancelltionToken) =>
            {
                var symbol = (INamedTypeSymbol)ctx.TargetSymbol;

                if (symbol.TypeKind != TypeKind.Structure || !ImplementsInterface(symbol, out var interfaceSymbol))
                {
                    return null;
                }

                var types = interfaceSymbol
                    !.TypeArguments
                    .Select(static ta => ta.ToDisplayString())
                    .ToValueList();

                return new StructDefinition
                {
                    Namespace = symbol.ContainingNamespace.ToDisplayString(),
                    Name = symbol.Name,
                    FullName = symbol.Name + GenerateTypeParamsString(symbol),
                    Types = types,
                };
            }
        );

        context.RegisterSourceOutput(provider, static (context, model) =>
        {
            if (model is null)
            {
                return;
            }

            var generatedFileName = $"{model.Name}.g.cs";
            var source = GenerateCode(model.Namespace, model.FullName, model.Types);

            context.AddSource(generatedFileName, source);
        });

        static string GenerateTypeParamsString(INamedTypeSymbol symbol)
        {
            return symbol.TypeParameters.Length == 0
                ? ""
                : $"<{string.Join(",", symbol
                        .TypeParameters
                        .Select(static tp => tp.Name))}>";
        }
    }

    public static string GenerateCode(string @namespace, string fullName, IReadOnlyList<string> types)
    {
        var sourceBuilder = new StringBuilder($$"""
                    // <auto-generated/>
                    namespace {{@namespace}};

                    public partial struct {{fullName}}
                    {
                        private bool _initialized;
                        private object _thing;
                        public object Thing
                        {
                            get
                            {
                                return _initialized ? _thing : default({{types[0]}});
                            }
                            private set
                            {
                                _initialized = true;
                                _thing = value;
                            }
                        }
                    """);

        foreach (string type in types)
        {
            sourceBuilder.AppendLine($$"""

                        public static implicit operator {{fullName}}({{type}} t)
                        {
                            return new {{fullName}} { Thing = t };
                        }
                    """);
        }

        sourceBuilder.AppendLine("""
                    }
                    """);

        return sourceBuilder.ToString();
    }

    private static bool ImplementsInterface(INamedTypeSymbol symbol, out INamedTypeSymbol? interfaceSymbol)
    {
        //TODO make sure two IEithers are not implemented?
        //TODO build an analyzer and maybe codefixes that help decorate the type the way it needs to be?
        for (int i = 0; i < symbol.Interfaces.Length; i++)
        {
            if (symbol.Interfaces[i].Name.Equals("IEither", StringComparison.Ordinal) &&
                symbol.Interfaces[i].Arity > 1)
            {
                interfaceSymbol = symbol.Interfaces[i];
                return true;
            }
        }
        interfaceSymbol = null;
        return false;
    }
}

file record class StructDefinition
{
    public string Namespace { get; set; } = "";
    public string Name { get; set; } = "";
    public string FullName { get; set; } = "";
    public ValueList<string> Types { get; set; }
}

file readonly struct ValueList<T>(IReadOnlyList<T> items) : IReadOnlyList<T>, IEquatable<ValueList<T>>
{
    private readonly IReadOnlyList<T> _items = items;

    public int Count => _items.Count;

    public T this[int index] => _items[0];

    public IEnumerator<T> GetEnumerator()
    {
        return _items.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    public readonly bool Equals(ValueList<T> other) => _items.SequenceEqual(other._items);

    public override bool Equals(object? obj) => obj is ValueList<T> other && Equals(other);

    public override readonly int GetHashCode() => _items.Count;
}

file static class ValueListExtensions
{
    public static ValueList<T> ToValueList<T>(this IEnumerable<T> source)
    {
        return new ValueList<T>(source.ToList());
    }
}
