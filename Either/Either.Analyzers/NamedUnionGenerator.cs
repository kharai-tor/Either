using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace RhymesOfUncertainty;

[Generator]
public class NamedUnionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: "RhymesOfUncertainty.NamedUnionTypeAttribute",
            predicate: static (node, cancellationToken) => node.IsKind(SyntaxKind.StructDeclaration),
            transform: static (ctx, cancelltionToken) =>
            {
                var symbol = (INamedTypeSymbol)ctx.TargetSymbol;

                //TODO check if it's a partial type
                if (!ImplementsInterface(symbol, out var interfaceSymbol))
                {
                    return default((string Name, string Namespace, ImmutableArray<string> Types)?);
                }

                var types = interfaceSymbol
                    !.TypeArguments
                    .Select(ta => ta.ToDisplayString())
                    .ToImmutableArray();

                return (symbol.Name, symbol.ContainingNamespace.ToDisplayString(), types);
            }
        );

        context.RegisterSourceOutput(provider, static (context, model) =>
        {
            if (model is null)
            {
                return;
            }

            var generatedFileName = $"{model.Value.Name}.g.cs";
            var source = GenerateCode(model.Value.Namespace, model.Value.Name, model.Value.Types);

            context.AddSource(generatedFileName, source);
        });
    }

    public static string GenerateCode(string @namespace, string structName, IList<string> types)
    {
        var sourceBuilder = new StringBuilder($$"""
                    // <auto-generated/>
                    namespace {{@namespace}};

                    public partial struct {{structName}}
                    {
                        private bool _initialized;
                        private object _thing;
                        public object Thing 
                        { 
                            get
                            {
                                return _initialized ? _thing : default({{types[0]}});
                            }
                            private set
                            {
                                _initialized = true;
                                _thing = value;
                            }
                        }
                    """);

        foreach (string type in types)
        {
            sourceBuilder.AppendLine($$"""

                        public static implicit operator {{structName}}({{type}} t)
                        {
                            return new {{structName}} { Thing = t };
                        }
                    """);
        }

        sourceBuilder.AppendLine("""
                    }
                    """);

        return sourceBuilder.ToString();
    }

    private static bool ImplementsInterface(INamedTypeSymbol symbol, out INamedTypeSymbol? interfaceSymbol)
    {
        //TODO build an analyzer and maybe codefixes that help decorate the type the way it needs to be
        for (int i = 0; i < symbol.Interfaces.Length; i++)
        {
            if (symbol.Interfaces[i].Name.Equals("IEither", StringComparison.Ordinal) &&
                symbol.Interfaces[i].Arity > 1)
            {
                interfaceSymbol = symbol.Interfaces[i];
                return true;
            }
        }
        interfaceSymbol = null;
        return false;
    }
}
